Compiling main
g++ ./main.cpp ./Interface_impls/WheelDriver_impl.cpp ./Dezyne_framework/runtime.cc ./Generated_code/BallControl.cc ./Generated_code/Commands.cc ./Generated_code/PositioningControl.cc ./Generated_code/Robot.cc ./Generated_code/Tactics.cc ./Generated_code/WheelControl.cc -o main_prog.o -std=c++11 -I . -I ./Interface_impls -I ./Dezyne_framework -I ./Generated_code
./main.cpp: In function ‘void BindFunctions(Robot&)’:
./main.cpp:18:39: error: no match for ‘operator=’ (operand types are ‘std::function<returnResult::type()>’ and ‘returnResult()’)
  robot.My_WheelDriver.in.getToTheBall = WheelDriver_impl::getToTheBall;
                                       ^
./main.cpp:18:39: note: candidates are:
In file included from ./Dezyne_framework/meta.hh:5:0,
                 from ./Dezyne_framework/runtime.hh:4,
                 from ./main.cpp:2:
/usr/include/c++/4.8/functional:2273:7: note: std::function<_Res(_ArgTypes ...)>& std::function<_Res(_ArgTypes ...)>::operator=(const std::function<_Res(_ArgTypes ...)>&) [with _Res = returnResult::type; _ArgTypes = {}]
       operator=(const function& __x)
       ^
/usr/include/c++/4.8/functional:2273:7: note:   no known conversion for argument 1 from ‘returnResult()’ to ‘const std::function<returnResult::type()>&’
/usr/include/c++/4.8/functional:2291:7: note: std::function<_Res(_ArgTypes ...)>& std::function<_Res(_ArgTypes ...)>::operator=(std::function<_Res(_ArgTypes ...)>&&) [with _Res = returnResult::type; _ArgTypes = {}]
       operator=(function&& __x)
       ^
/usr/include/c++/4.8/functional:2291:7: note:   no known conversion for argument 1 from ‘returnResult()’ to ‘std::function<returnResult::type()>&&’
/usr/include/c++/4.8/functional:2305:7: note: std::function<_Res(_ArgTypes ...)>& std::function<_Res(_ArgTypes ...)>::operator=(std::nullptr_t) [with _Res = returnResult::type; _ArgTypes = {}; std::nullptr_t = std::nullptr_t]
       operator=(nullptr_t)
       ^
/usr/include/c++/4.8/functional:2305:7: note:   no known conversion for argument 1 from ‘returnResult()’ to ‘std::nullptr_t’
/usr/include/c++/4.8/functional:2334:2: note: template<class _Functor> std::function<_Res(_ArgTypes ...)>::_Requires<std::__and_<std::__not_<std::is_same<typename std::decay<_Tp>::type, std::function<_Res(_ArgTypes ...)> > >, std::__or_<std::is_void<_Tp>, std::is_convertible<std::function<_Res(_ArgTypes ...)>::_Invoke<typename std::decay<_Tp>::type>, _Res> > >, std::function<_Res(_ArgTypes ...)>&> std::function<_Res(_ArgTypes ...)>::operator=(_Functor&&) [with _Functor = _Functor; _Res = returnResult::type; _ArgTypes = {}]
  operator=(_Functor&& __f)
  ^
/usr/include/c++/4.8/functional:2334:2: note:   template argument deduction/substitution failed:
/usr/include/c++/4.8/functional:2343:2: note: template<class _Functor> std::function<_Res(_ArgTypes ...)>& std::function<_Res(_ArgTypes ...)>::operator=(std::reference_wrapper<_Tp>) [with _Functor = _Functor; _Res = returnResult::type; _ArgTypes = {}]
  operator=(reference_wrapper<_Functor> __f) noexcept
  ^
/usr/include/c++/4.8/functional:2343:2: note:   template argument deduction/substitution failed:
./main.cpp:18:39: note:   mismatched types ‘std::reference_wrapper<_Tp>’ and ‘returnResult (*)()’
  robot.My_WheelDriver.in.getToTheBall = WheelDriver_impl::getToTheBall;
                                       ^
./Interface_impls/WheelDriver_impl.cpp: In static member function ‘static returnResult WheelDriver_impl::getToTheBall()’:
./Interface_impls/WheelDriver_impl.cpp:8:14: error: expected unqualified-id before ‘.’ token
  returnResult.succes;
              ^
make: *** [main] Error 1
